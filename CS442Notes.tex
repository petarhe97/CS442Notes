\documentclass[11pt]{article}
\usepackage{amsthm}
\usepackage{fullpage}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage[official]{eurosym}
\usepackage[]{algorithm2e}
\usepackage[normalem]{ulem}
\usepackage{color}
\usepackage{tcolorbox}


\newcommand{\remove}[1]{{}}
\newcommand{\ignore}[1]{{}}
\newcommand{\rednote}[1]{{\color{red} #1}}
\newcommand{\bluenote}[1]{{\color{blue} #1}}




\begin{document}

\noindent
{Winter 2020 \hfill Zi Hao He}


\begin{center}
{\large\bf CS442 Notes}
\end{center}
\bigskip

\section{Functional Programming}

\begin{itemize}
\item[-] to begin: Functional Programming in general, not a particular language
\item[-] need a model \begin{itemize}
\item[-] simple
\item[-] powerful enough to be useful
\end{itemize}
\end{itemize}

\textbf{Church-Turing Thesis:} Any algorithm can be simulated on a Turing machine. \\

\textbf{Alan Turing}
\begin{itemize}
\item[-] Turing machine
\item[-] not an inspiring model for programming
\end{itemize}

\textbf{Alonzo Church}
\begin{itemize}
\item[-] $\lambda$-calculus
\item[-] equivalent to Turing Machines
\item[-] the basis for all of functional programming
\end{itemize}

\subsection{Untyped Lambda-Calculus}

\textbf{Calculus}
\begin{itemize}
\item[-] a system or method of calculation
\item[-] syntax + rules for manipulating syntax
\end{itemize}
\textbf{Lambda-Calculus} (1934) - "a calculus of functions" \\ \\
\textbf{Syntax}: Abstract Syntax
\begin{align*}
& variable, abstraction, application \\
<expr> &::= <var> | <abs> | <app> \\
<var> &::= a | b | c \\
& \text{variable and body} \\
<abs> &::= \lambda <var>.<expr> \\
& \text{rator and rand} \\
<app> &::= <expr> <expr>
\end{align*}

Use parenthesis to disambiguate parses \\

\textbf{Conventions:}
\begin{enumerate}
\item Abstractions extend as far to the right as possible
	\begin{itemize}
		\item[e.g.] $\lambda x.y\;z = \lambda x.(y\;z) \neq (\lambda x.y)\;z$
	\end{itemize}
\item Applications associate left-to-right
	\begin{itemize}
		\item[e.g.] $x\;y\;z = (x\;y)\;z \neq x\;(y\;z)$
	\end{itemize}
\end{enumerate}

\textbf{Interpretation}
	\begin{itemize}
		\item[-] Var: Self explanatory
		\item[-] Abs: $\lambda x.E =$ "function" taking argument x and returning expr E
		\item[-] App: $M\;N$ - result of applying "function" M to argument N
	\end{itemize}

\textbf{Consider:}
\begin{itemize}
\item[] $\lambda x.x$ - Here the first $x$ is a binding occurrence and second $x$ is a bound occurrence.
\item[] $\lambda x.x\;y\;x$ - The $y$ is a free occurrence (fully parenthesized function is $\lambda x.((x\;y)\;x)$)
\item[] $\lambda x.x\;(\lambda x.x)\;x$ - Same variable name might be bound in difference places as long as the scope is not clashing
\item[] $x\;\lambda x.x$ - The $x$ in the front is free while the other one is bound
\end{itemize}

\textbf{Informally:}
\begin{itemize}
\item[] A variable is bound if it has a bound occurrence.
\item[] A variable is free if it has a free occurrence
\item[] The same variable can be used in both bound and free occurrences
\end{itemize}

\textbf{Formally:} \\

\textbf{Definition:} Let E be an expression. The bound variables of E, $B \cup [E]$ are given by 
\begin{itemize}
	\item[] $B \cup [x] = \emptyset$
	\item[] $B \cup [\lambda x.E] = B \cup [E] \cup \{x\}$
	\item[] $B \cup [M\;N] = B \cup [M] \cup B \cup [N]$
\end{itemize}


$x$ is bound in $E$ if $x \in B \cup [E]$ \\

The free variables of $E$, $F \cup [E]$ are given by
\begin{itemize}
	\item[] $F \cup [x] = \{x\}$
	\item[] $F \cup [\lambda x.E] = F \cup [E] \setminus \{x\}$
	\item[] $F \cup [M\;N] = F \cup [M] \cup F \cup [N]$
\end{itemize}

$x$ is free in $E$ if $x \in F \cup [E]$ \\

A variable can be both bound and free: $F \cup [x\; \lambda x.x] = B \cup [x\; \lambda x.x] = \{x\}$ \\

But each occurrence is either bound or free, not both \\

Two occurrences of a variable $x$ "mean the same thing" if
\begin{enumerate}
\item they are both free occurrences
\item OR they have the same binding occurrence
\end{enumerate}

$\lambda x.\lambda y.y\;x$ and $\lambda a.\lambda b.b\;a$ these should mean the same thing \\

$\lambda x.y\;x$ and $\lambda x.w\;x$ should not mean the same thing because $y$ and $w$ do not have to be the same free variable \\

You can change the names of bound variables, but not free ones. \\

\textbf{Formally:} \\

\textbf{Definition ($\alpha$-conversion):} For all $x$, $y$, $M$, $\lambda x.M =_\alpha \lambda y.M[y/x]$ if $y \notin F \cup [M]$ \\

$M[N/x] =$ "substitute $N$ for $x$ in $M$" \\

More generally, if $C[\lambda x.M]$ denotes an expr in which $\lambda x.M$ occurs as a subexpression, then $C[\lambda x.M] =_\alpha C[\lambda y.M[y/x]]$ if $y \notin F \cup [M]$. \\

e.g. 
\begin{itemize}
	\item[] $\lambda x.x =_\alpha \lambda y.y$
	\item[] $x\;\lambda x.x =_\alpha x\;\lambda a.a$
	\item[] $\lambda a.b\;a =_\alpha \lambda c.b\;c \neq_\alpha \lambda b.b\;b \neq_\alpha \lambda a.d\;a$
\end{itemize}

\textbf{Computation:} \\

Expr. $(\lambda x.M)\;N$ is called a ($\beta$-)redex (reductible expression) \\

We expect: $(\lambda x.M)\;N \Rightarrow$ evaluate $M$, with $N$ substituted for $x$ i.e. $M[N/x]$ \\

\textbf{Definition ($\beta$-reduction):} For all $M$, $N$, $x$, $(\lambda x.M)\;N \rightarrow_\beta M[N/x]$ \\

More generally - for all contexts $C$, $C[(\lambda x.M)\;N] \rightarrow_\beta C[M[N/x]]$ \\

$\rightarrow_\beta$ is a binary relation on terms

\begin{itemize}
	\item[] $A \rightarrow_\beta B$: $A$ beta reduces to $B$ in one step
	\item[] $A \rightarrow_\beta^n B$: $A$ beta reduces to $B$ in $n$ steps
	\item[] $A \rightarrow_\beta^* B$: $A$ beta reduces to $B$ in 0 or more steps
	\item[] $A \rightarrow_\beta^+ B$: $A$ beta reduces to $B$ in 1 or more steps
\end{itemize}

\textbf{Evaluating $M[N/x]$} \\

Want: Substitute $N$ for all free occurrences of $x$ in $M$ \\

\textbf{Definition (substitution, naive(wrong)):} 
\begin{itemize}
	\item[] $x[E/x] = E$
	\item[] $y[E/x] = y$, $y \neq x$
	\item[] $(M\;N)[E/x] = M[E/x]\;N[E/x]$
	\item[] $(\lambda x.P)[E/x] = \lambda x.P$
	\item[] $(\lambda y.P)[E/x] = \lambda y. P[E/x]$, $y \neq x$
\end{itemize}

E.g. 
\begin{align*}
(\lambda x.x\;y)\;z &\rightarrow_\beta (x\;y)[z/x] \\
&= x[z/x]\;y[z/x] \\
&= z\;y \\ \\
(\lambda x.x)\;a &\rightarrow_\beta x[a/x] = a \\ \\
(\lambda x. \lambda y.x)\;a\;b &\rightarrow_\beta (\lambda y.x)[a/x]\;b \\
&= (\lambda y.x[a/x])\;b \\
&= (\lambda y.a)\;b \\
&\rightarrow_\beta a[b/y] \\
&= a \\ \\
(\lambda x. \lambda y.y)\;a\;b &\rightarrow_\beta (\lambda y.y)[a/x]\;b \\
&= (\lambda y.y[a/x])\;b \\
&= (\lambda y.y)\;b \\
&\rightarrow_\beta y[b/y] \\
&= b
\end{align*}

\textbf{Consider:}
\begin{align*}
(\lambda x. \lambda y.x)\;y\;w &\rightarrow_\beta (\lambda y.x)[y/x]\;w \\
&= (\lambda y.x[y/x])\;w \\
&= (\lambda y.y)\;w \\
&\rightarrow_\beta y[w/y] \\
&= w
\end{align*}

We can see from this that the last rule of $(\lambda y.P)[E/x] = \lambda y.P[E/x]$, $y \neq x$ must be wrong. \\

What happened? Free variable $y$ became bound after substitution \\

As a result, the binding occurrence of $x$ changed \\

$\lambda x.\lambda y.x \leftarrow$ the inner $x$ is bound to the $\lambda x$ on the outside. \\

This is called {\bf Dynamic binding} - meaning of variables uncertain until runtime \\

We want {\bf static binding} - meanings of variables fixed before runtime \\

\textbf{Definition (substitution, fixed):}
\begin{itemize}
	\item[] $x[E/x] = E$
	\item[] $y[E/x] = y$, $y \neq x$
	\item[] $(M\;N)[E/x] = M[E/x]\;N[E/x]$
	\item[] $(\lambda x.P)[E/x] = \lambda x.P$
	\item[] $(\lambda y.P)[E/x] = \lambda y. P[E/x]$, $y \notin F \cup [E]$
	\item[] $(\lambda y.P)[E/x] = \lambda z.(P[z/y][E/x])$, $y \in F \cup [E]$, $z$ a "fresh" variable
\end{itemize}

Now 
\begin{align*}
(\lambda x.\lambda y.x)\;y\;w &\rightarrow_\beta (\lambda y.x)[y/x]\;w \\
&= (\lambda z.x[z/y][y/x])\;w \\
&= (\lambda z.x[y/x])\;w \\
&= (\lambda z.y)\;w \\
&\rightarrow_\beta y[w/z] \\
&= y
\end{align*}

{\bf Computation:} $\beta$-reduction until you reach a {\bf Normal Form}. \\

\textbf{Definition ($\beta$-Normal Form):} An expr is in $\beta$ Normal Form if it has no $\beta$-redices. \\

\textbf{Definition (Weak Normal Form):} An expr is in Weak Normal Form if the only $\beta$-redices are inside abstractions. e.g. $\lambda z.(\lambda x.x)\;y$. \\

Usually, "Normal Form" will mean $\beta$-Normal Form. \\

{\bf Consider:} 
\begin{align*}
(\lambda x.x)((\lambda y.y)\;z) &\rightarrow_\beta x[((\lambda y.y)\;z)/x] \\
&= (\lambda y.y)\;z \\
&\rightarrow_\beta y[z/y] \\
&= z
\end{align*}

Or

\begin{align*}
(\lambda x.x)((\lambda y.y)\;z) &\rightarrow_\beta (\lambda x.x)(y[z/y]) \\
&= (\lambda x.x)\;z \\
&\rightarrow_\beta x[z/x] \\
&= z
\end{align*}

- two difference reduction sequences. Does it matter which we take? \\

\textbf{Theorem (Church-Rosser):} Let $E_1,E_2,E_3$ be expressions such that $E_1 \rightarrow_\beta^* E_2$ and $E_1 \rightarrow_\beta^* E_3$. Then there is an expression $E_4$ such that (up to $\alpha$-equivalence) $E_2 \rightarrow_\beta^* E_4$ and $E_3 \rightarrow_\beta^* E_4$. \\

{\bf Immediate Consequence -} An expr $E$ can have at most one $\beta$-Normal Form (modulo $\alpha$-equivalence) \\

Do all expressions have a $\beta$-NF? No!\\

{\bf Consider:}
\begin{align*}
(\lambda x.x\;x)(\lambda x.x\;x) &\rightarrow_\beta (x\;x)[(\lambda x.x\;x)/x] \\
&= (\lambda x.x\;x)(\lambda x.x\;x)
\end{align*}

It does not have a $\beta$-NF because it always reduces to itself. \\

Which exprs have a $\beta$-NF? - undecidable - equivalent to Halting Problem \\

{\bf Consider:}
\begin{align*}
(\lambda x.y)((\lambda x.x\;x)(\lambda x.x\;x)) \rightarrow_\beta (\lambda x.y)((\lambda x.x\;x)(\lambda x.x\;x)) \rightarrow_\beta \cdots
\end{align*}

Or, the alternate way of reducing this

\begin{align*}
(\lambda x.y)((\lambda x.x\;x)(\lambda x.x\;x)) &\rightarrow_\beta y[(\lambda x.x\;x)(\lambda x.x\;x)/x] \\
&= y
\end{align*}

$\therefore$ Order does matter when $\infty$-reductions are possible. \\

{\bf Reduction Strategies} - "plans" for choosing a redex to reduce. \\

{\bf Applicative Order Reductions (AOR)}: Choose the leftmost, innermost redex. 
\begin{itemize}
	\item[-] Innermost = not containing any other redex 
	\item[-] This is called "eager evaluation" 
\end{itemize}

{\bf Normal Order Reduction (NOR):} Choose the leftmost,outermost
\begin{itemize}
	\item[-] outermost = not contained in any other redex
	\item[-] "lazy evaluation"
\end{itemize}

To the example earlier, the one the results in infinite reduction is AOR and the one that go the $\beta$-NF form is NOR. \\

e.g. 
\begin{align*}
(\lambda x.x)((\lambda y.y)\;z) &\xrightarrow{\text{AOR}}_\beta (\lambda x.x)\;z \xrightarrow{\text{AOR}}_\beta z \\
(\lambda x.x)((\lambda y.y)\;z) &\xrightarrow{\text{NOR}}_\beta (\lambda y.y)\;z \xrightarrow{\text{NOR}}_\beta z
\end{align*}

{\bf Theorem (Standardization):} If an expr as a $\beta$-NF, then NOR is guaranteed to reach it. \\

But most proramming languages use applicative order, including Scheme. \\

{\bf $\eta$-reduction:} Consider $(\lambda x.y\;x)\;z \rightarrow_\beta (y\;x)[z/x] = y\;z$ \\

So $\lambda x.y\;x$ behaves exactly like $z$ \\

\textbf{Definition ($\eta$-reduction):} $\lambda x.M\;x \rightarrow_\eta M$ if $x \notin F \cup [M]$ \\

More generally, $C[\lambda x.M\;x] \rightarrow_\eta C[M]$ if $x \notin F \cup [M]$ \\

So we have $\lambda x.y\;x \rightarrow_\eta y$ \\

\subsection{Programming in the $\lambda$-Calculus}

Shorthand for convenience: $[[\cdot]]$: (real-world programming language) $\rightarrow \lambda$-calculus \\

For a real-world expr $E$, $[[E]]$ is our representation of $E$ in the $\lambda$-calculus \\

e.g. $[[id]] = \lambda x.x$ \\

{\bf Note:} $[[\cdot]]$ is just shorthand. An expression containing $[[\cdot]]$ is not $\lambda$-calculus until all $[[\cdot]]$s have been replaced with what they represent. \\

{\bf Booleans:} Let $[[$true$]] = \lambda x.\lambda y.x$ and $[[$false$]] = \lambda x.\lambda y.y$. \\

if <bool> then <true-part> else <false-part> \\

if($b,t,f$) = if $b$ then $t$ else $f$ \\ 

$[[$if$]] = \lambda b. \lambda t.\lambda f.b\;t\;f$ \\

Note that $\lambda b. \lambda t.\lambda f.b\;t\;f \rightarrow_\eta^2 \lambda b.b$ \\

Alternatively, $[[$if B then T else F$]] = [[B]][[T]][[F]]$ \\

Does it work? \\

\begin{align*}
[[\text{if true then P else Q}]] &= [[true]][[P]][[Q]] \\
&= (\lambda x.\lambda y.x)[[P]][[Q]] \\
&\rightarrow_\beta [[P]]
\end{align*}

\begin{align*}
[[\text{if false then P else Q}]] &= [[false]][[P]][[Q]] \\
&= (\lambda x.\lambda y.y)[[P]][[Q]] \\
&\rightarrow_\beta [[Q]]
\end{align*}

Now, for the definition of {\bf Not}:

\begin{align*}
[[not]] &= \lambda b.[[\text{if b then false else true}]] \\
&= \lambda b.b[[false]][[true]] \\
&= \lambda b.b(\lambda x.\lambda y.y)(\lambda x.\lambda y.x)
\end{align*}

We can test it:

\begin{align*}
[[\text{not true}]] &= (\lambda b.b[[false]][[true]])\;[[true]] \\
&\rightarrow_\beta [[true]][[false]][[true]] \\
&= (\lambda x.\lambda y.x)[[false]][[true]] \\
&\rightarrow_\beta^2 [[false]]
\end{align*}

For the definition of {\bf And}: 

\begin{align*}
[[and]] &= \lambda p.\lambda q.[[\text{if p then q else false}]] \\
&= \lambda p.\lambda q.p\;q\;[[false]]
\end{align*}

For the definition of {\bf Or}: 

\begin{align*}
[[and]] &= \lambda p.\lambda q.[[\text{if p then true else q}]] \\
&= \lambda p.\lambda q.p\;[[true]]\;q
\end{align*}

\textbf{Storage:} Use lists. Scheme - lists based on pairs.
\begin{itemize}
	\item[] (cons a b) creates the pair
	\item[] (cons a (cons b c)) creates the list
	\item[] $\therefore$ nested pairs create lists
\end{itemize}

{\bf Need to implement:}
\begin{itemize}
	\item cons
	\item nil - empty list
	\item null? - is the list empty?
	\item car - first component of the pair
	\item cdr - 2nd component of the pair
\end{itemize}

{\bf Modelling pairs:} pair - function that takes a {\bf selector} as a parameter \\

If the selector is true - return the first component \\

If the selector is true - return the second component \\

i.e. $[[pair]] = \lambda s.[[$if s then h else t$]]$ where s is the selector, h is the head, t is the tail. \\

So $[[pair]] = \lambda s.s\;h\;t$ \\

Then $[[cons]] = \lambda h.\lambda t.\lambda s.s\;h\;t$ \\

e.g. 
\begin{align*}
[[\text{cons a (cons b nil)}]] &= [[cons]]\;a\;([[cons]]\;b\;[[nil]]) \\
&= (\lambda h.\lambda t.\lambda s.s\;h\;t)\;a\;([[cons]]\;b\;[[nil]]) \\
&\rightarrow_\beta^2 \lambda s.s\;a\;([[cons]]\;b\;[[nil]]) \\
&= \lambda s.s\;a((\lambda h.\lambda t.\lambda s.s\;h\;t)\;b\;[[nil]]) \\
&\rightarrow_\beta^2 \lambda s.s\;a\;(\lambda s.s\;b\;[[nil]]) 
\end{align*}

{\bf car:} return the head $\Rightarrow$ pass the selector "true" \\

$[[car]] = \lambda l.l\;[[true]] = \lambda l.l\;(\lambda x.\lambda y.x)$ \\

Similarly, {\bf cdr:} return the tail $\Rightarrow$ pass the selector "false" \\

$[[cdr]] = \lambda l.l\;[[false]] = \lambda l.l\;(\lambda x.\lambda y.y)$ \\

\end{document}
